--- a/options.c
+++ b/options.c
@@ -106,7 +106,7 @@
 /*
  * Set an option by name in the structure.
  * name is the name of the option as in tftp_def.c.
- * name is it's new value, that must comply with the rfc's.
+ * value is it's new value, that must comply with the rfc's.
  * When setting an option, it is marked as specified.
  * 
  */
@@ -232,6 +232,17 @@
      return ERR;
 }
 
+int opt_get_windowsize(struct tftp_opt *options)
+{
+     int windowsize;
+     if (options[OPT_WINDOWSIZE].enabled && options[OPT_WINDOWSIZE].specified)
+     {
+          windowsize = atoi(options[OPT_WINDOWSIZE].value);
+          return windowsize;
+     }
+     return ERR;
+}
+
 int opt_get_multicast(struct tftp_opt *options, char *addr, int *port, int *mc)
 {
      char *token = NULL;
@@ -300,6 +311,11 @@
      snprintf(options[OPT_BLKSIZE].value, VAL_SIZE, "%d", blksize);
 }
 
+void opt_set_windowsize(int windowsize, struct tftp_opt *options)
+{
+     snprintf(options[OPT_WINDOWSIZE].value, VAL_SIZE, "%d", windowsize);
+}
+
 void opt_set_multicast(struct tftp_opt *options, char *addr, int port, int mc)
 {
      snprintf(options[OPT_MULTICAST].value, VAL_SIZE, "%s,%d,%d", addr, port,
--- a/options.h
+++ b/options.h
@@ -35,14 +35,19 @@
 int opt_get_options(struct tftp_opt *options, char *name, char *value);
 int opt_disable_options(struct tftp_opt *options, char *name);
 int opt_support_options(struct tftp_opt *options);
+
 int opt_get_tsize(struct tftp_opt *options);
 int opt_get_timeout(struct tftp_opt *options);
 int opt_get_blksize(struct tftp_opt *options);
+int opt_get_windowsize(struct tftp_opt *options);
 int opt_get_multicast(struct tftp_opt *options, char *addr, int *port, int *mc);
+
 void opt_set_tsize(int tsize, struct tftp_opt *options);
 void opt_set_timeout(int timeout, struct tftp_opt *options);
 void opt_set_blksize(int blksize, struct tftp_opt *options);
+void opt_set_windowsize(int windowsize, struct tftp_opt *options);
 void opt_set_multicast(struct tftp_opt *options, char *addr, int port, int mc);
+
 void opt_request_to_string(struct tftp_opt *options, char *string, int len);
 void opt_options_to_string(struct tftp_opt *options, char *string, int len);
 
--- a/tftp_def.h
+++ b/tftp_def.h
@@ -35,14 +35,15 @@
 #define	MAXBLOCKS     ((1 << (32 - 9)) - 1)  /* Maximum blocks we will xfer */
 
 /* definition to use tftp_options structure */
-#define OPT_FILENAME  0
-#define OPT_MODE      1
-#define OPT_TSIZE     2
-#define OPT_TIMEOUT   3
-#define OPT_BLKSIZE   4
-#define OPT_MULTICAST 5
-#define OPT_PASSWORD  6
-#define OPT_NUMBER    7         /* number of OPT_xx options */
+#define OPT_FILENAME   0
+#define OPT_MODE       1
+#define OPT_TSIZE      2
+#define OPT_TIMEOUT    3
+#define OPT_BLKSIZE    4
+#define OPT_MULTICAST  5
+#define OPT_PASSWORD   6
+#define OPT_WINDOWSIZE 7
+#define OPT_NUMBER     8         /* number of OPT_xx options */
 
 #define OPT_SIZE     12
 #define VAL_SIZE     MAXLEN
--- a/tftpd.c
+++ b/tftpd.c
@@ -652,7 +652,7 @@
      /* Read the first packet from stdin. */
      data_size = data->data_buffer_size;
      retval = tftp_get_packet(0, -1, NULL, &data->client_info->client, NULL,
-                              &to, data->timeout, &data_size,
+                              &to, data->timeout, 0, &data_size,
                               data->data_buffer);
      if (retval == ERR) {
           logger(LOG_NOTICE, "Invalid request in 1st packet");
@@ -930,6 +930,7 @@
           { "no-timeout", 0, NULL, 'T' },
           { "no-tsize", 0, NULL, 'S' },
           { "no-blksize", 0, NULL, 'B' },
+          { "no-windowsize", 0, NULL, 'W' },
           { "no-multicast", 0, NULL, 'M' },
           { "logfile", 1, NULL, 'L' },
           { "pidfile", 1, NULL, 'I'},
@@ -1006,6 +1007,9 @@
           case 'B':
                tftp_default_options[OPT_BLKSIZE].enabled = 0;
                break;
+          case 'W':
+               tftp_default_options[OPT_WINDOWSIZE].enabled = 0;
+               break;
           case 'M':
                tftp_default_options[OPT_MULTICAST].enabled = 0;
                break;
@@ -1169,16 +1173,18 @@
      else
           logger(LOG_INFO, "  request per minute limit: ---");
 #endif
-     logger(LOG_INFO, "  option timeout:   %s",
+     logger(LOG_INFO, "  option timeout:    %s",
             tftp_default_options[OPT_TIMEOUT].enabled ? "enabled":"disabled");
-     logger(LOG_INFO, "  option tzise:     %s",
+     logger(LOG_INFO, "  option tzise:      %s",
             tftp_default_options[OPT_TSIZE].enabled ? "enabled":"disabled");
-     logger(LOG_INFO, "  option blksize:   %s",
+     logger(LOG_INFO, "  option blksize:    %s",
             tftp_default_options[OPT_BLKSIZE].enabled ? "enabled":"disabled");
-     logger(LOG_INFO, "  option multicast: %s",
+     logger(LOG_INFO, "  option windowsize: %s",
+            tftp_default_options[OPT_WINDOWSIZE].enabled ? "enabled":"disabled");
+     logger(LOG_INFO, "  option multicast:  %s",
             tftp_default_options[OPT_MULTICAST].enabled ? "enabled":"disabled");
-     logger(LOG_INFO, "     address range: %s", mcast_addr);
-     logger(LOG_INFO, "     port range:    %s", mcast_port);
+     logger(LOG_INFO, "     address range:  %s", mcast_addr);
+     logger(LOG_INFO, "     port range:     %s", mcast_port);
 #ifdef HAVE_PCRE
      if (pcre_top)
           logger(LOG_INFO, "  PCRE: using file: %s", pcre_file);
@@ -1255,6 +1261,7 @@
             "  --no-timeout               : disable 'timeout' from RFC2349\n"
             "  --no-tsize                 : disable 'tsize' from RFC2349\n"
             "  --no-blksize               : disable 'blksize' from RFC2348\n"
+            "  --no-windowsize            : disable 'windowsize' from RFC7440\n"
             "  --no-multicast             : disable 'multicast' from RFC2090\n"
             "  --logfile <file>           : logfile to log logs to ;-) (use - for stdout)\n"
             "  --pidfile <file>           : write PID to this file\n"
--- a/tftpd_file.c
+++ b/tftpd_file.c
@@ -99,7 +99,7 @@
  *
  *     1) send a ACK or OACK
  *     2) wait replay
- *          - if DATA packet, read it, send an acknoledge, goto 2
+ *          - if DATA packet, read it, send an acknowledge, goto 2
  *          - if ERROR abort
  *          - if TIMEOUT goto previous state
  */
@@ -107,8 +107,11 @@
 {
      int state = S_BEGIN;
      int timeout_state = state;
+     int windowblock = 0;         /* number of block in a window, c.f. RFC7440 */
+     int windowsize = 1;          /* c.f. RFC7440 */
      int result;
      long block_number = 0;
+     long last_received_block = 0;
      int data_size;
      int sockfd = data->sockfd;
      struct sockaddr_storage *sa = &data->client_info->client;
@@ -238,29 +241,32 @@
                     state = S_SEND_ACK;
                break;
           case S_SEND_ACK:
+               windowblock = 0;
                timeout_state = state;
-               tftp_send_ack(sockfd, sa, block_number);
+               tftp_send_ack(sockfd, sa, last_received_block);
                if (data->trace)
-                    logger(LOG_DEBUG, "sent ACK <block: %ld>", block_number);
+                    logger(LOG_DEBUG, "sent ACK <block: %ld>", last_received_block);
                if (all_blocks_received)
                     state = S_END;
                else
                     state = S_WAIT_PACKET;
                break;
           case S_SEND_OACK:
+               windowblock = 0;
                timeout_state = state;
                tftp_send_oack(sockfd, sa, data->tftp_options,
                               data->data_buffer, data->data_buffer_size);
-               opt_options_to_string(data->tftp_options, string, MAXLEN);
                if (data->trace)
+               {
+                    opt_options_to_string(data->tftp_options, string, MAXLEN);
                     logger(LOG_DEBUG, "sent OACK <%s>", string);
+               }
                state = S_WAIT_PACKET;
                break;
           case S_WAIT_PACKET:
                data_size = data->data_buffer_size;
                result = tftp_get_packet(sockfd, -1, NULL, sa, &from, NULL,
-                                        timeout, &data_size, data->data_buffer);
-               
+                                        timeout, 0, &data_size, data->data_buffer);
                switch (result)
                {
                case GET_TIMEOUT:
@@ -274,7 +280,7 @@
                     }
                     else
                     {
-                         logger(LOG_WARNING, "timeout: retrying...");
+                         logger(LOG_WARNING, "timeout: retrying ...");
                          state = timeout_state;
                     }
                     break;
@@ -358,15 +364,24 @@
                }
 
                /* We need to seek to the right place in the file */
-	       block_number = tftp_rollover_blocknumber(
+               block_number = tftp_rollover_blocknumber(
 		      ntohs(tftphdr->th_block), prev_block_number, 0);
+               /* The first data package acknowledges the OACK */
+               if ((last_received_block < windowsize) && (timeout_state = S_SEND_OACK))
+                    timeout_state = S_SEND_ACK;
+               if (last_received_block + 1 != block_number)
+               {
+                    logger(LOG_DEBUG, "got wrong block <block: %ld>", block_number);
+                    state = S_SEND_ACK;
+                    break;
+               }
+               windowblock++;
                if (data->trace)
-                    logger(LOG_DEBUG, "received DATA <block: %ld, size: %d>",
-                           block_number, data_size - 4);
-
+                    logger(LOG_DEBUG, "received %d. DATA <block: %ld, size %d>, update last received block: %ld → %ld>",
+                           windowblock, block_number, data_size - 4, last_received_block, block_number);
+               last_received_block = block_number;
                if (tftp_file_write(fp, tftphdr->th_data, data->data_buffer_size - 4, block_number,
-                                   data_size - 4, convert, &prev_block_number, &temp)
-                   != data_size - 4)
+                                   data_size - 4, convert, &prev_block_number, &temp) != data_size - 4)
                {
                     logger(LOG_ERR, "%s: %d: error writing to file %s",
                            __FILE__, __LINE__, filename);
@@ -382,7 +397,10 @@
                     all_blocks_received = 1;
                else
                     all_blocks_received = 0;
-               state = S_SEND_ACK;
+               if ((windowblock >= windowsize) || (all_blocks_received))
+                    state = S_SEND_ACK;
+               else
+                    state = S_WAIT_PACKET;
                break;
           case S_END:
                if (fp != NULL) fclose(fp);
@@ -419,6 +437,7 @@
      int timeout_state = state;
      int result;
      long block_number = 0;
+     long last_ackd_block = -1;
      long last_block = -1;
      int data_size;
      struct sockaddr_storage *sa = &data->client_info->client;
@@ -430,6 +449,8 @@
      char filename[MAXLEN];
      char string[MAXLEN];
      int timeout = data->timeout;
+     int windowblock = 0;
+     int windowsize = 1;
      int number_of_timeout = 0;
      int mcast_switch = data->mcast_switch_client;
      struct stat file_stat;
@@ -445,6 +466,12 @@
      long prev_block_number = 0; /* needed to support netascii conversion */
      long prev_file_pos = 0;
      int temp = 0;
+     struct timeval current_time = {0, 0};
+     long long current = 0L;
+     struct timeval previous_time = {0, 0};
+     long long previous = 0L;
+     int rtt = 0;
+     int delta = 0;
 
      long prev_sent_block = -1;
      int prev_sent_count = 0;
@@ -544,24 +571,11 @@
           logger(LOG_INFO, "timeout option -> %d", timeout);
      }
 
-     /*
-      *  blksize option, must be the last option evaluated,
-      *  because data->data_buffer_size may be modified here,
-      *  and may be smaller than the buffer containing options
-      */
-     if ((result = opt_get_blksize(data->tftp_options)) > -1)
+     /* windowsize option */
+     if ((result = opt_get_windowsize(data->tftp_options)) > -1)
      {
-          /*
-           *  If we receive more options, we have to make sure our buffer for
-           *  the OACK is not too small.  Use the string representation of
-           *  the options here for simplicity, which puts us on the save side.
-           *  FIXME: Use independent buffers for OACK and data.
-           */
-          opt_options_to_string(data->tftp_options, string, MAXLEN);
-          if ((result < strlen(string)-2) || (result > 65464))
+          if ((result < 1) || (result > 65535))
           {
-               logger(LOG_NOTICE, "options <%s> require roughly a blksize of %d for the OACK.",
-                      string, strlen(string)-2);
                tftp_send_error(sockfd, sa, EOPTNEG, data->data_buffer, data->data_buffer_size);
                if (data->trace)
                     logger(LOG_DEBUG, "sent ERROR <code: %d, msg: %s>", EOPTNEG,
@@ -569,42 +583,9 @@
                fclose(fp);
                return ERR;
           }
-
-          data->data_buffer_size = result + 4;
-          data->data_buffer = realloc(data->data_buffer, data->data_buffer_size);
-
-          if (data->data_buffer == NULL)
-          {
-               logger(LOG_ERR, "memory allocation failure");
-               fclose(fp);
-               return ERR;
-          }
-          tftphdr = (struct tftphdr *)data->data_buffer;
-
-          if (data->data_buffer == NULL)
-          {
-               tftp_send_error(sockfd, sa, ENOSPACE, data->data_buffer, data->data_buffer_size);
-               if (data->trace)
-                    logger(LOG_DEBUG, "sent ERROR <code: %d, msg: %s>", ENOSPACE,
-                           tftp_errmsg[ENOSPACE]);
-               fclose(fp);
-               return ERR;
-          }
-          opt_set_blksize(result, data->tftp_options);
-          logger(LOG_INFO, "blksize option -> %d", result);
-     }
-
-     /* Verify that the file can be sent in MAXBLOCKS blocks of BLKSIZE octets */
-     if ((file_stat.st_size / (data->data_buffer_size - 4)) > MAXBLOCKS)
-     {
-          tftp_send_error(sockfd, sa, EUNDEF, data->data_buffer, data->data_buffer_size);
-          logger(LOG_NOTICE, "Requested file too big, increase BLKSIZE");
-          logger(LOG_NOTICE, "Only %d blocks of %d bytes can be served via multicast", MAXBLOCKS, data->data_buffer_size);
-          if (data->trace)
-               logger(LOG_DEBUG, "sent ERROR <code: %d, msg: %s>", EUNDEF,
-                      tftp_errmsg[EUNDEF]);
-          fclose(fp);
-          return ERR;
+          windowsize = result;
+          opt_set_windowsize(windowsize, data->tftp_options);
+          logger(LOG_INFO, "windowsize option -> %d", windowsize);
      }
 
      /* multicast option */
@@ -654,9 +635,11 @@
                   not be a problem: the client thread will receive a second OACK and fall
                   back to non master mode. Then the server will timeout and either resend
                   OACK or continu with the next client */
-               opt_options_to_string(data->tftp_options, string, MAXLEN);
                if (data->trace)
+               {
+                    opt_options_to_string(data->tftp_options, string, MAXLEN);
                     logger(LOG_DEBUG, "sent OACK <%s>", string);
+               }
                tftp_send_oack(thread->sockfd, sa, data->tftp_options,
                               data->data_buffer, data->data_buffer_size);
 
@@ -729,6 +712,69 @@
           }
      }
 
+     /*
+      *  blksize option, must be the last option evaluated,
+      *  because data->data_buffer_size may be modified here,
+      *  and may be smaller than the buffer containing options
+      */
+     if ((result = opt_get_blksize(data->tftp_options)) > -1)
+     {
+          /*
+           *  If we have more options, we have to make sure our buffer for
+           *  the OACK is not too small.  Use the string representation of
+           *  the options here for simplicity, which puts us on the save side.
+           *  Better solution: Do not use the same buffer for OACK and data.
+           */
+          opt_options_to_string(data->tftp_options, string, MAXLEN);
+          if ((result < strlen(string)-2) || (result > 65464))
+          {
+               logger(LOG_NOTICE, "options <%s> require roughly a blksize of %d for the OACK.",
+                      string, strlen(string)-2);
+               tftp_send_error(sockfd, sa, EOPTNEG, data->data_buffer, data->data_buffer_size);
+               if (data->trace)
+                    logger(LOG_DEBUG, "sent ERROR <code: %d, msg: %s>", EOPTNEG,
+                           tftp_errmsg[EOPTNEG]);
+               fclose(fp);
+               return ERR;
+          }
+
+          data->data_buffer_size = result + 4;
+          data->data_buffer = realloc(data->data_buffer, data->data_buffer_size);
+
+          if (data->data_buffer == NULL)
+          {
+               logger(LOG_ERR, "memory allocation failure");
+               fclose(fp);
+               return ERR;
+          }
+          tftphdr = (struct tftphdr *)data->data_buffer;
+
+          if (data->data_buffer == NULL)
+          {
+               tftp_send_error(sockfd, sa, ENOSPACE, data->data_buffer, data->data_buffer_size);
+               if (data->trace)
+                    logger(LOG_DEBUG, "sent ERROR <code: %d, msg: %s>", ENOSPACE,
+                           tftp_errmsg[ENOSPACE]);
+               fclose(fp);
+               return ERR;
+          }
+          opt_set_blksize(result, data->tftp_options);
+          logger(LOG_INFO, "blksize option -> %d", result);
+     }
+
+     /* Verify that the file can be sent in MAXBLOCKS blocks of BLKSIZE octets */
+     if ((file_stat.st_size / (data->data_buffer_size - 4)) > MAXBLOCKS)
+     {
+          tftp_send_error(sockfd, sa, EUNDEF, data->data_buffer, data->data_buffer_size);
+          logger(LOG_NOTICE, "Requested file too big, increase BLKSIZE");
+          logger(LOG_NOTICE, "Only %d blocks of %d bytes can be served via multicast", MAXBLOCKS, data->data_buffer_size);
+          if (data->trace)
+               logger(LOG_DEBUG, "sent ERROR <code: %d, msg: %s>", EUNDEF,
+                      tftp_errmsg[EUNDEF]);
+          fclose(fp);
+          return ERR;
+     }
+
      /* copy options to local structure, used when falling back a client to slave */
      memcpy(options, data->tftp_options, sizeof(options));
      opt_set_multicast(options, data->mc_addr, data->mc_port, 0);
@@ -766,24 +812,21 @@
                break;
           case S_SEND_OACK:
                timeout_state = state;
-               opt_options_to_string(data->tftp_options, string, MAXLEN);
                if (data->trace)
+               {
+                    opt_options_to_string(data->tftp_options, string, MAXLEN);
                     logger(LOG_DEBUG, "sent OACK <%s>", string);
+               }
                tftp_send_oack(sockfd, sa, data->tftp_options,
                               data->data_buffer, data->data_buffer_size);
                state = S_WAIT_PACKET;
                break;
           case S_SEND_DATA:
+               windowblock++;
                timeout_state = state;
-
                data_size = tftp_file_read(fp, tftphdr->th_data, data->data_buffer_size - 4, block_number,
                                           convert, &prev_block_number, &prev_file_pos, &temp);
                data_size += 4;  /* need to consider tftp header */
-
-               /* record the last block number */
-               if (feof(fp))
-                    last_block = block_number;
-
                if (multicast)
                {
                     tftp_send_data(sockfd, &data->sa_mcast,
@@ -794,16 +837,43 @@
                {
                     tftp_send_data(sockfd, sa, block_number + 1,
                                    data_size, data->data_buffer);
+                    if (tftp_default_options[OPT_WINDOWSIZE].enabled && (windowblock == windowsize))
+                    {
+                         gettimeofday(&previous_time, NULL);
+                         previous = (long long)previous_time.tv_sec*1000000L + previous_time.tv_usec;
+                    }
                }
                if (data->trace)
-                    logger(LOG_DEBUG, "sent DATA <block: %ld, size %d>",
-                           block_number + 1, data_size - 4);
+                    logger(LOG_DEBUG, "sent %d. DATA <block: %ld, size %d>",
+                           windowblock, block_number + 1, data_size - 4);
                state = S_WAIT_PACKET;
+               /* record the last block number */
+               if (feof(fp))
+                    last_block = block_number;
+               else
+                    block_number = tftp_rollover_blocknumber(
+                         ntohs(tftphdr->th_block), prev_block_number, 0);
                break;
           case S_WAIT_PACKET:
                data_size = data->data_buffer_size;
-               result = tftp_get_packet(sockfd, -1, NULL, sa, &from, NULL,
-                                        timeout, &data_size, data->data_buffer);
+               if ((windowblock >= windowsize) || (block_number == 0) || (last_block != -1))
+               {
+                    /* we wait for the ACK */
+                    result = tftp_get_packet(sockfd, -1, NULL, sa, &from, NULL,
+                                             timeout, 0, &data_size, data->data_buffer);
+               }
+               else
+               {
+                    /* we check if an unsolicitated ACK arrived */
+                    result = tftp_get_packet(sockfd, -1, NULL, sa, &from, NULL,
+                                             0, delta, &data_size, data->data_buffer);
+                    if (result == GET_TIMEOUT)
+                    {
+                         /* we send the next block */
+                         state = S_SEND_DATA;
+                         break;
+                    }
+               }
                switch (result)
                {
                case GET_TIMEOUT:
@@ -831,10 +901,12 @@
                               {
                                    /* Send an OACK to the old client remove is
                                       master client status */
-                                   opt_options_to_string(options,
-                                                         string, MAXLEN);
+
                                    if (data->trace)
+                                   {
+                                        opt_options_to_string(options, string, MAXLEN);
                                         logger(LOG_DEBUG, "sent OACK <%s>", string);
+                                   }
                                    tftp_send_oack(sockfd, sa, options,
                                                   data->data_buffer, data->data_buffer_size);
 
@@ -865,7 +937,9 @@
                                    break;
                               }
                          }
-                         logger(LOG_WARNING, "timeout: retrying...");
+                         logger(LOG_WARNING, "timeout: retrying ...");
+                         if (tftp_default_options[OPT_WINDOWSIZE].enabled)
+                              block_number = last_ackd_block;
                          state = timeout_state;
                     }
                     break;
@@ -896,15 +970,15 @@
                               else
                                    /* If not, send and OACK with mc=0 to shut it up. */
                               {
-                                   opt_options_to_string(options,
-                                                         string, MAXLEN);
                                    if (data->trace)
+                                   {
+                                        opt_options_to_string(options, string, MAXLEN);
                                         logger(LOG_DEBUG, "sent OACK <%s>", string);
+                                   }
                                    tftp_send_oack(sockfd, &from, options,
                                                   data->data_buffer, data->data_buffer_size);
                               }
                               break;
-                              
                          }
                     }
                     else
@@ -927,7 +1001,21 @@
                     }
 
                     /* The ACK is from the current client */
+                    if (tftp_default_options[OPT_WINDOWSIZE].enabled && (windowblock == windowsize))
+                    {
+                         gettimeofday(&current_time, NULL);
+                         current = (long long)current_time.tv_sec*1000000L + current_time.tv_usec;
+                         rtt = current - previous;
+                         /* ignore round trip times greater than 1/100 of the timeout */
+                         if (rtt < timeout*10000)
+                         {
+                              delta = delta + (rtt/20 - delta)/10;
+                              if (data->trace)
+                                   logger(LOG_DEBUG, "use RTT %lld usec, delta=%d ", rtt, delta);
+                         }
+                    }
                     number_of_timeout = 0;
+                    windowblock = 0;
 		    if (multicast)
 			    block_number = ntohs(tftphdr->th_block);
 		    else
@@ -936,8 +1024,7 @@
 				ntohs(tftphdr->th_block), prev_block_number, 0);
 		    }
                     if (data->trace)
-                         logger(LOG_DEBUG, "received ACK <block: %ld>",
-                                block_number);
+                         logger(LOG_DEBUG, "received ACK <block: %ld>", block_number);
 
                     /* Now check the ACK number and possibly ignore the request */
 
@@ -978,52 +1065,67 @@
                                    break;
                               }
                          }
-                         /* unicast, blocks should be requested one after another */
                     } else {
-                         /* if turned on, check whether the block request isn't already fulfilled */
-                         if (tftpd_prevent_sas) {
-                              if (prev_sent_block + 1 != block_number) {
-                                   logger(LOG_WARNING, "timeout: retrying...");
+                         /* unicast, blocks should be requested one after another */
+                         if (tftp_default_options[OPT_WINDOWSIZE].enabled) {
+                              /* windowsize option */
+                              logger(LOG_DEBUG, "RTT is %lld usec, delta=%lld ", rtt, delta);
+                              if (last_ackd_block > block_number)
+                              {
                                    if (data->trace)
-                                        logger(LOG_DEBUG, "received out of order ACK <block: %d != %d>", prev_sent_block + 1, block_number);
+                                        logger(LOG_DEBUG, "ignore outdated ACK <block: %ld < %ld>",
+                                               block_number, last_ackd_block);
                                    break;
-                              } else {
-                                   prev_sent_block = block_number;
                               }
-                              /* don't prevent thes SAS */
-                              /* use a heuristic suggested by Vladimir Nadvornik */
+                         } else {
+                              /* if turned on, check whether the block request isn't already fulfilled */
+                              if (tftpd_prevent_sas) {
+                                   if (prev_sent_block + 1 != block_number) {
+                                        logger(LOG_WARNING, "timeout: retrying...");
+                                        if (data->trace)
+                                             logger(LOG_DEBUG, "received out of order ACK <block: %d != %d>", prev_sent_block + 1, block_number);
+                                        break;
+                                   } else {
+                                        prev_sent_block = block_number;
+                                   }
+                                   /* don't prevent thes SAS */
+                                   /* use a heuristic suggested by Vladimir Nadvornik */
                               } else {
-                              /* here comes the ACK again */
-                              if (prev_sent_block == block_number) {
-                                   /* drop if number of ACKs == times of previous block sending */
-                                   if (++prev_ack_count == prev_sent_count) {
-                                        logger(LOG_DEBUG, "ACK count (%d) == previous block transmission count -> dropping ACK", prev_ack_count);
+                                   /* here comes the ACK again */
+                                   if (prev_sent_block == block_number) {
+                                        /* drop if number of ACKs == times of previous block sending */
+                                        if (++prev_ack_count == prev_sent_count) {
+                                             logger(LOG_DEBUG, "ACK count (%d) == previous block transmission count -> dropping ACK", prev_ack_count);
+                                             break;
+                                        }
+                                        /* else resend the block */
+                                        logger(LOG_DEBUG, "resending block %d", block_number + 1);
+                                   }
+                                   /* received ACK to sent block -> move on to next block */
+                                   else if (prev_sent_block < block_number) {
+                                        prev_sent_block = block_number;
+                                        prev_sent_count = curr_sent_count;
+                                        curr_sent_count = 0;
+                                        prev_ack_count = 1;
+                                   }
+                                   /* nor previous nor current block number -> ignore it completely */
+                                   else {
+                                        logger(LOG_DEBUG, "ignoring ACK %d", block_number);
                                         break;
                                    }
-                                   /* else resend the block */
-                                   logger(LOG_DEBUG, "resending block %d", block_number + 1);
-                              }
-                              /* received ACK to sent block -> move on to next block */
-                              else if (prev_sent_block < block_number) {
-                                   prev_sent_block = block_number;
-                                   prev_sent_count = curr_sent_count;
-                                   curr_sent_count = 0;
-                                   prev_ack_count = 1;
-                              }
-                              /* nor previous nor current block number -> ignore it completely */
-                              else {
-                                   logger(LOG_DEBUG, "ignoring ACK %d", block_number);
-                                   break;
                               }
                          }
                     }
-
                     if ((last_block != -1) && (block_number > last_block))
                     {
                          state = S_END;
                          break;
                     }
-
+                    if (tftp_default_options[OPT_WINDOWSIZE].enabled && (block_number != (last_ackd_block + windowsize)) && (last_ackd_block != -1))
+                         logger(LOG_WARNING, "window not complete/ordered: %ld/%d valid", block_number - last_ackd_block, windowsize);
+                    if (tftp_default_options[OPT_WINDOWSIZE].enabled && (data->trace))
+                         logger(LOG_DEBUG, "update last ACK'd <block: %ld → %ld>", last_ackd_block, block_number);
+                    last_ackd_block = block_number;
                     curr_sent_count++;
                     state = S_SEND_DATA;
                     break;
@@ -1069,10 +1171,12 @@
                          }
                     }
                     /* Got an ERROR from the current master client */
-                    Strncpy(string, tftphdr->th_msg, sizeof(string));
                     if (data->trace)
+                    {
+                         Strncpy(string, tftphdr->th_msg, sizeof(string));
                          logger(LOG_DEBUG, "received ERROR <code: %d, msg: %s>",
                                 ntohs(tftphdr->th_code), string);
+                    }
                     if (multicast)
                     {
                          logger(LOG_DEBUG, "Marking client as done");
--- a/tftp_def.c
+++ b/tftp_def.c
@@ -33,13 +33,14 @@
 
 // FIXME: is there a way to use TIMEOUT and SEGSIZE here?
 struct tftp_opt tftp_default_options[OPT_NUMBER + 1] = {
-     { "filename", "", 0, 1},   /* file to transfer */
-     { "mode", "octet", 0, 1},  /* mode for transfer */
-     { "tsize", "0", 0, 1 },    /* RFC1350 options. See RFC2347, */
-     { "timeout", "5", 0, 1 },  /* 2348, 2349, 2090.  */
-     { "blksize", "512", 0, 1 }, /* This is the default option */
-     { "multicast", "", 0, 1 }, /* structure */
-     { "password", "", 0, 1},   /* password */
+     { "filename", "", 0, 1},     /* file to transfer */
+     { "mode", "octet", 0, 1},    /* mode for transfer */
+     { "tsize", "0", 0, 1 },      /* RFC1350 options. See RFC2347, */
+     { "timeout", "5", 0, 1 },    /* 2348, 2349, 2090.  */
+     { "blksize", "512", 0, 1 },  /* This is the default option */
+     { "multicast", "", 0, 1 },   /* structure */
+     { "password", "", 0, 1},     /* password */
+     { "windowsize", "1", 0, 1 }, /* Default without RFC7440 */
      { "", "", 0, 0}
 };
 
--- a/tftp_file.c
+++ b/tftp_file.c
@@ -111,14 +111,17 @@
  */
 int tftp_receive_file(struct client_data *data)
 {
-     int state = S_SEND_REQ;    /* current state in the state machine */
-     int timeout_state = state; /* what state should we go on when timeout */
+     int state = S_SEND_REQ;       /* current state in the state machine */
+     int timeout_state = state;    /* what state should we go on when timeout */
+     int windowblock = 0;          /* number of block in a window, c.f. RFC7440 */
+     int windowsize = 1;           /* c.f. RFC7440 */
      int result;
      long block_number = 0;
-     long last_block_number = -1;/* block number of last block for multicast */
-     int data_size;             /* size of data received */
-     int sockfd = data->sockfd; /* just to simplify calls */
-     struct sockaddr_storage sa; /* a copy of data.sa_peer */
+     long last_received_block = 0;
+     long last_block_number = -1;  /* block number of last block for multicast */
+     int data_size;                /* size of data received */
+     int sockfd = data->sockfd;    /* just to simplify calls */
+     struct sockaddr_storage sa;   /* a copy of data.sa_peer */
      struct sockaddr_storage from;
      char from_str[SOCKADDR_PRINT_ADDR_LEN];
      int connected;             /* 1 when sockfd is connected */
@@ -233,6 +236,7 @@
                                    call to tftp_send_request */
                break;
           case S_SEND_ACK:
+               windowblock = 0;
                timeout_state = S_SEND_ACK;
                if (multicast)
                {
@@ -242,8 +246,8 @@
                     block_number = prev_bitmap_hole;
                }
                if (data->trace)
-                    fprintf(stderr, "sent ACK <block: %ld>\n", block_number);
-               tftp_send_ack(sockfd, &sa, block_number);
+                    fprintf(stderr, "sent ACK <block: %ld>\n", last_received_block);
+               tftp_send_ack(sockfd, &sa, last_received_block);
                /* if we just ACK the last block we are done */
                if (block_number == last_block_number)
                     state = S_END;
@@ -255,7 +259,7 @@
                if (multicast)
                {
                     result = tftp_get_packet(sockfd, mcast_sockfd, NULL, &sa, &from,
-                                             NULL, data->timeout, &data_size,
+                                             NULL, data->timeout, 0, &data_size,
                                              data->data_buffer);
                     /* RFC2090 state we should verify source address as well
                        as source port */
@@ -268,7 +272,7 @@
                else
                {
                     result = tftp_get_packet(sockfd, -1, NULL, &sa, &from, NULL,
-                                             data->timeout, &data_size,
+                                             data->timeout, 0, &data_size,
                                              data->data_buffer);
                     /* Check that source port match */
                     if ((sockaddr_get_port(&sa) != sockaddr_get_port(&from)) &&
@@ -406,8 +410,8 @@
                     memcpy(data->tftp_options_reply, tftp_default_options,
                            sizeof(tftp_default_options));
                     /*
-                     * look in the returned string for tsize, timeout, blksize
-                     * or multicast
+                     * look in the returned string for tsize, timeout,
+                     * blksize, windowsize or multicast
                      */
                     opt_disable_options(data->tftp_options_reply, NULL);
                     opt_parse_options(data->data_buffer, data_size,
@@ -415,22 +419,26 @@
                     if (data->trace)
                          fprintf(stderr, "received OACK <");
                     /* tsize: funny, now we know the file size */
-                    if ((result = opt_get_tsize(data->tftp_options_reply)) >
-                        -1)
+                    if ((result = opt_get_tsize(data->tftp_options_reply)) > -1)
                     {
                          if (data->trace)
                               fprintf(stderr, "tsize: %d, ", result);
                     }
+                    /* windowsize */
+                    if ((result = opt_get_windowsize(data->tftp_options_reply)) > -1)
+                    {
+                         if (data->trace)
+                              fprintf(stderr, "windowsize: %d, ", result);
+                         windowsize = result;
+                    }
                     /* timeout */
-                    if ((result = opt_get_timeout(data->tftp_options_reply))
-                        > -1)
+                    if ((result = opt_get_timeout(data->tftp_options_reply)) > -1)
                     {
                          if (data->trace)
                               fprintf(stderr, "timeout: %d, ", result);
                     }
                     /* blksize: resize the buffer please */
-                    if ((result = opt_get_blksize(data->tftp_options_reply))
-                        > -1)
+                    if ((result = opt_get_blksize(data->tftp_options_reply)) > -1)
                     {
                          if (data->trace)
                               fprintf(stderr, "blksize: %d, ", result);
@@ -538,15 +546,22 @@
 		    block_number = tftp_rollover_blocknumber(
 			ntohs(tftphdr->th_block), prev_block_number, 0);
 	       }
+               if ((last_received_block < windowsize) && (timeout_state = S_SEND_OACK))
+                    timeout_state = S_SEND_ACK;
+               if (last_received_block + 1 != block_number)
+               {
+                    fprintf(stderr, "got wrong block <block: %ld>\n", block_number);
+                    state = S_SEND_ACK;
+                    break;
+               }
+               windowblock++;
                if (data->trace)
-                    fprintf(stderr, "received DATA <block: %ld, size: %d>\n",
-                            block_number, data_size - 4);
-
+                    fprintf(stderr, "received %d. DATA <block: %ld, size %d>, update last received block: %ld → %ld\n",
+                            windowblock, block_number, data_size - 4, last_received_block, block_number);
+               last_received_block = block_number;
                if (tftp_file_write(fp, tftphdr->th_data, data->data_buffer_size - 4, block_number,
-                                   data_size - 4, convert, &prev_block_number, &temp)
-                   != data_size - 4)
+                                   data_size - 4, convert, &prev_block_number, &temp) != data_size - 4)
                {
-
                     fprintf(stderr, "tftp: error writing to file %s\n",
                             data->local_file);
                     tftp_send_error(sockfd, &sa, ENOSPACE, data->data_buffer,
@@ -566,13 +581,18 @@
                          |= (1 << ((block_number - 1) % 32));
                     /* if we are the master client we ack, else
                        we just wait for data */
-                    if (master_client || !multicast)
+                    if (master_client || !multicast)  // FIXME
                          state = S_SEND_ACK;
                     else
                          state = S_WAIT_PACKET;
                }
                else
-                    state = S_SEND_ACK;
+               {
+                    if ((windowblock >= windowsize) || (last_block_number != -1))
+                         state = S_SEND_ACK;
+                    else
+                         state = S_WAIT_PACKET;
+               }
                break;
           case S_END:
           case S_ABORT:
@@ -628,6 +648,8 @@
 {
      int state = S_SEND_REQ;    /* current state in the state machine */
      int timeout_state = state; /* what state should we go on when timeout */
+     int windowblock = 0;       /* number of block in a window, c.f. RFC7440 */
+     int windowsize = 1;        /* c.f. RFC7440 */
      int result;
      long block_number = 0;
      long last_requested_block = -1;
@@ -747,21 +769,41 @@
                                           convert, &prev_block_number, &prev_file_pos, &temp);
                data_size += 4;  /* need to consider tftp header */
 
-               if (feof(fp))
-                    last_block = block_number;
                tftp_send_data(sockfd, &sa, block_number + 1,
                               data_size, data->data_buffer);
                data->file_size += data_size;
+               windowblock++;
                if (data->trace)
-                    fprintf(stderr, "sent DATA <block: %ld, size: %d>\n",
-                            block_number + 1, data_size - 4);
+                    fprintf(stderr, "sent %d. DATA <block: %ld, size %d>\n",
+                           windowblock, block_number + 1, data_size - 4);
                state = S_WAIT_PACKET;
+               if (feof(fp))
+                    last_block = block_number;
+               else
+                    block_number = tftp_rollover_blocknumber(
+                         ntohs(tftphdr->th_block), prev_block_number, 0);
                break;
           case S_WAIT_PACKET:
                data_size = data->data_buffer_size;
-               result = tftp_get_packet(sockfd, -1, NULL, &sa, &from, NULL,
-                                        data->timeout, &data_size,
-                                        data->data_buffer);
+               if ((windowblock >= windowsize) || (block_number == 0) || (last_block != -1))
+               {
+                    windowblock = 0;
+                    /* we wait for the ACK */
+                    result = tftp_get_packet(sockfd, -1, NULL, &sa, &from, NULL,
+                                             data->timeout, 0, &data_size, data->data_buffer);
+               }
+               else
+               {
+                    /* we check if an unsolicitated ACK arrived */
+                    result = tftp_get_packet(sockfd, -1, NULL, &sa, &from, NULL,
+                                             0, 0, &data_size, data->data_buffer);
+                    if (result == GET_TIMEOUT)
+                    {
+                         /* we send the next block */
+                         state = S_SEND_DATA;
+                         break;
+                    }
+               }
                /* check that source port match */
                if (sockaddr_get_port(&sa) != sockaddr_get_port(&from))
                {
@@ -785,6 +827,7 @@
                     break;
                case GET_ACK:
                     number_of_timeout = 0;
+                    windowblock = 0;
                     /* if the socket if not connected, connect it */
                     if (!connected)
                     {
@@ -869,6 +912,13 @@
                     if (data->trace)
                          fprintf(stderr, "tsize: %d, ", result);
                }
+               /* windowsize */
+               if ((result = opt_get_windowsize(data->tftp_options_reply)) > -1)
+               {
+                    if (data->trace)
+                         fprintf(stderr, "windowsize: %d, ", result);
+                    windowsize = result;
+               }
                /* timeout */
                if ((result = opt_get_timeout(data->tftp_options_reply)) > -1)
                {
--- a/atftp.1
+++ b/atftp.1
@@ -69,12 +69,12 @@
 arguments as the interactive one. For example, use: --option "blksize 1428"
 to configure block size.
 .br
-Possible Values are:
+Possible settings are:
 .br
-  --option "tsize enable"
-  --option "tsize disable"
   --option "blksize 8"
   --option "blksize 65464"
+  --option "timeout 1"
+  --option "windowsize 4"
 
 .TP
 .B \-\-mtftp <"name value">
--- a/atftpd.8
+++ b/atftpd.8
@@ -74,6 +74,11 @@
 acknowledging the 'blksize' request by the client.
 
 .TP
+.B \-\-no\-windowsize
+disable 'windowsize' from RFC7440. This will prevent the server from
+acknowledging the 'windowsize' request by the client.
+
+.TP
 .B \-\-no\-multicast
 disable 'multicast' from RFC2090. This will prevent the server from
 acknowledging the 'multicast' request by the client.
@@ -134,7 +139,6 @@
 the packets don't leave the local network, see ip(4). Scope may also
 be determine by the address as described RFC2365.
 
-
 .TP
 .B \-\-mcast\-addr
 Specify the IP address range to be used for multicast transfer. Format
--- a/tftp.c
+++ b/tftp.c
@@ -528,27 +528,32 @@
           fprintf(stderr, "Usage: option <option name> [option value]\n");
           fprintf(stderr, "       option disable <option name>\n");
           if (data.tftp_options[OPT_TSIZE].specified)
-               fprintf(stderr, "  tsize:     enabled\n");
+               fprintf(stderr, "  tsize:      enabled\n");
           else
-               fprintf(stderr, "  tsize:     disabled\n");
+               fprintf(stderr, "  tsize:      disabled\n");
           if (data.tftp_options[OPT_BLKSIZE].specified)
-               fprintf(stderr, "  blksize:   %s\n",
+               fprintf(stderr, "  blksize:    %s\n",
                        data.tftp_options[OPT_BLKSIZE].value);
           else
-               fprintf(stderr, "  blksize:   disabled\n");
+               fprintf(stderr, "  blksize:    disabled\n");
+          if (data.tftp_options[OPT_WINDOWSIZE].specified)
+               fprintf(stderr, "  windowsize:   %s\n",
+                       data.tftp_options[OPT_WINDOWSIZE].value);
+          else
+               fprintf(stderr, "  windowsize: disabled\n");
           if (data.tftp_options[OPT_TIMEOUT].specified)
-               fprintf(stderr, "  timeout:   %s\n",
+               fprintf(stderr, "  timeout:    %s\n",
                        data.tftp_options[OPT_TIMEOUT].value);
           else
-               fprintf(stderr, "  timeout:   disabled\n");
+               fprintf(stderr, "  timeout:    disabled\n");
           if (data.tftp_options[OPT_MULTICAST].specified)
-               fprintf(stderr, "  multicast: enabled\n");
+               fprintf(stderr, "  multicast:  enabled\n");
           else
-               fprintf(stderr, "  multicast: disabled\n");
+               fprintf(stderr, "  multicast:  disabled\n");
           if (data.tftp_options[OPT_PASSWORD].specified)
-               fprintf(stderr, "   password: enabled\n");
+               fprintf(stderr, "  password:   enabled\n");
           else
-               fprintf(stderr, "   password: disabled\n");
+               fprintf(stderr, "  password:   disabled\n");
           return ERR;
      }
      /* if disabling an option */
--- a/tftp_io.c
+++ b/tftp_io.c
@@ -207,7 +207,7 @@
  */
 int tftp_get_packet(int sock1, int sock2, int *sock, struct sockaddr_storage *sa,
                     struct sockaddr_storage *sa_from, struct sockaddr_storage *sa_to,
-                    int timeout, int *size, char *data)
+                    int timeout, int timeout_usec, int *size, char *data)
 {
      int result;
      struct timeval tv;
@@ -235,7 +235,8 @@
 
      /* Wait up to five seconds. */
      tv.tv_sec = timeout;
-     tv.tv_usec = 0;
+     /* We wait that long for out-of-order ACKs between data packages. */
+     tv.tv_usec = timeout_usec;
 
      /* Watch socket to see when it has input. */
      FD_ZERO(&rfds);
--- a/tftp_io.h
+++ b/tftp_io.h
@@ -51,7 +51,7 @@
                    int size, char *data);
 int tftp_get_packet(int sock1, int sock2, int *sock, struct sockaddr_storage *sa,
                     struct sockaddr_storage *from, struct sockaddr_storage *to,
-                    int timeout, int *size, char *data);
+                    int timeout, int timeout_usec, int *size, char *data);
 int tftp_file_read(FILE *fp, char *buffer, int buffer_size, long block_number, int convert,
                    long *prev_block_number, long *prev_file_pos, int *temp);
 int tftp_file_write(FILE *fp, char *data_buffer, int data_buffer_size, long block_number,
--- a/tftp_mtftp.c
+++ b/tftp_mtftp.c
@@ -328,7 +328,7 @@
                data_size = data->data_buffer_size;
                /* receive the data */
                result = tftp_get_packet(sockfd, mcast_sockfd, &sock, &sa, &from,
-					NULL, timeout, &data_size,
+					NULL, timeout, 0, &data_size,
 					data->data_buffer);
                switch (result)
                {
--- a/tftpd_mtftp.c
+++ b/tftpd_mtftp.c
@@ -389,7 +389,7 @@
                memset(&sa, 0, sizeof(sa)); /* this will hold the client info */
                data_size = data->data_buffer_size;
                retval = tftp_get_packet(sockfd, -1, NULL, &sa, NULL, NULL,
-                                        data->timeout,
+                                        data->timeout, 0,
                                         &data_size, data->data_buffer);
 
 #ifdef HAVE_WRAP
@@ -596,7 +596,7 @@
           case S_WAIT_PACKET:
                data_size = data->data_buffer_size;
                result = tftp_get_packet(sockfd, -1, NULL, sa, &from, NULL,
-                                        data->mtftp_data->timeout,
+                                        data->mtftp_data->timeout, 0,
                                         &data_size, data->data_buffer);
 
                switch (result)
